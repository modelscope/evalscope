from collections.abc import Mapping, Sequence
from pydantic import BaseModel, Field
from typing import Any, Callable, Dict, List, Optional, Protocol, Union, runtime_checkable

from evalscope.utils.logger import get_logger

logger = get_logger(name=__name__)

CORRECT = 'C'
"""Value to assign for correct answers."""

INCORRECT = 'I'
"""Value to assign for incorrect answers."""

PARTIAL = 'P'
"""Value to assign for partial credit."""

NOANSWER = 'N'
"""Value to assign for no answer or refusal to answer."""

Value = Union[
    Union[str, int, float, bool],
    Sequence[Union[str, int, float, bool]],
    Mapping[str, Union[str, int, float, bool, None]],
]
"""Value provided by a score.

Use the methods of `Score` to easily treat
the `Value` as a simple scalar of various types.
"""


class Score(BaseModel):
    """Score generated by a scorer."""

    value: Value
    """Score value."""

    answer: Optional[str] = Field(default=None)
    """Answer extracted from model output (optional)"""

    explanation: Optional[str] = Field(default=None)
    """Explanation of score (optional)."""

    metadata: Optional[Dict[str, Any]] = Field(default=None)
    """Additional metadata related to the score"""

    @property
    def text(self) -> str:
        """Read the score as text."""
        return self.as_str()

    def as_str(self) -> str:
        """Read the score as a string."""
        return str(self._as_scalar())

    def as_int(self) -> int:
        """Read the score as an integer."""
        return int(self._as_scalar())

    def as_float(self) -> float:
        """Read the score as a float."""
        return float(self._as_scalar())

    def as_bool(self) -> bool:
        """Read the score as a boolean."""
        return bool(self._as_scalar())

    def as_list(self) -> List[Union[str, int, float, bool]]:
        """Read the score as a list."""
        if isinstance(self.value, list):
            return self.value
        else:
            raise ValueError('This score is not a list')

    def as_dict(self) -> Dict[str, Union[str, int, float, bool, None]]:
        """Read the score as a dictionary."""
        if isinstance(self.value, dict):
            return self.value
        else:
            raise ValueError('This score is not a dictionary')

    def _as_scalar(self) -> Union[str, int, float, bool]:
        if isinstance(self.value, (str, int, float, bool)):
            return self.value
        else:
            raise ValueError('This score is not a scalar')


class SampleScore(BaseModel):
    """Score for a Sample."""

    score: Score
    """A score"""

    sample_id: Optional[Union[str, int]] = Field(default=None)
    """A sample id"""

    sample_metadata: Optional[Dict[str, Any]] = Field(default=None)
    """Metadata from the sample"""

    scorer: Optional[str] = Field(default=None)
    """Registry name of scorer that created this score."""


ValueToFloat = Callable[[Value], float]
"""Function used by metrics to translate from a Score value to a float value."""


def value_to_float(
    correct: Value = CORRECT,
    incorrect: Value = INCORRECT,
    partial: Value = PARTIAL,
    noanswer: Value = NOANSWER,
) -> ValueToFloat:
    """Create a ValueToFloat function.

    Create a ValueToFloat function that maps scalar values of
    different types into floats. For strings, common boolean
    representations (e.g. 'yes', 'no', 'true', 'false') are
    mapped to 1 and 0. In addition, the specified correct,
    incorrect, partial, and noanswer values (by default "C"
    "I", "P", and "N") are mapped to 1, 0, 0.5, and 0. Note that
    those are the default literal values, but they can be
    customized. Strings with only numbers are converted, and
    numeric values are cast to float. Arrays and dictionaries
    give a warning and return 0.

    Args:
       correct (Value): Value that represents a correct answer (1)
       incorrect (Value): Value that represents an incorrect answer (0)
       partial (Value): Value to assign partial credit for (0.5)
       noanswer (Value): Value for refusals to answer (0)

    Returns:
        ValueToFloat function.
    """

    def to_float(value: Value) -> float:
        if isinstance(value, (int, float, bool)):
            return float(value)
        elif value == correct:
            return 1.0
        elif value == partial:
            return 0.5
        elif value == incorrect or value == noanswer:
            return 0
        elif isinstance(value, str):
            value = value.lower()
            if value in ['yes', 'true']:
                return 1.0
            elif value in ['no', 'false']:
                return 0.0
            elif value.replace('.', '').isnumeric():
                return float(value)

        # couldn't extract a value
        logger.warning(f'Unable to convert value to float: {value}')
        return 0.0

    return to_float


@runtime_checkable
class MetricProtocol(Protocol):

    def __call__(self, scores: List[SampleScore]) -> Value:
        r"""Compute a metric on a list of scores.

        Args:
          scores: List of scores.

        Returns:
          Metric value

        Examples:
          ```python
          @metric
          def mean() -> Metric:
              def metric(scores: List[SampleScore]) -> Value:
                  return np.mean([score.score.as_float() for score in scores]).item()
              return metric
          ```
        """
        ...


Metric = MetricProtocol
